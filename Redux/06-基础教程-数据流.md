Redux架构专注于一种严格的单向数据流。  
这意味着应用中的所有数据都遵循同样的生命周期模式，使你的应用逻辑更可预测，更容易理解。它也鼓励数据普通化，这样你不会遇到数据重复冗余。
如果你还没被说服，你可以阅读[动机](https://redux.js.org/introduction/motivation)和双向数据流的[Flux示例](https://medium.com/@dan_abramov/the-case-for-flux-379b7d1982c6)。虽然Redux不是Flux，它也有着同样的优点。
任意一个Redux应用的数据生命周期遵循一下四步：
1. **调用[store.dispatch(action)](https://redux.js.org/api/store#dispatchaction)**。

action是单纯的对象，描述*发生了什么*。例子：
```
{ type: 'LIKE_ARTICLE', articleId: 42 }
 { type: 'FETCH_USER_SUCCESS', response: { id: 3, name: 'Mary' } }
 { type: 'ADD_TODO', text: 'Read the Redux docs.' }
```
把action想象成一则简短的新闻。“玛丽喜欢42号文章”，或“‘阅读Redux文档’被加入todos的列表中。”  
你可以在应用的任何地方调用[store.dispatch(action)](https://redux.js.org/api/store#dispatchaction)，包括组件、网络请求函数的回调、甚至是计时器。
2. **Redux store调用你提供的reducer函数**。

